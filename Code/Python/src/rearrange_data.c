#line 1 "src\\rearrange_data.c.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- Mode: C -*- */
/* Common code for creating GUFuncs with BLAS/Lapack

These functions copy matrices back anf forth between numpy and fortran forms
Many BLAS/Lapack routines require inputs in (semi)contiguous fortran form
and modify the inputs, so data needs to be copied.
*/
/*
Adapted from https://github.com/numpy/numpy/numpy/linalg/umath_linalg.c.src
Copyright/licence info for that file:
* Copyright (c) 2005-2017, NumPy Developers.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*   - Redistributions of source code must retain the above
*     copyright notice, this list of conditions and the
*     following disclaimer.
*   - Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer
*     in the documentation and/or other materials provided with the
*     distribution.
*   - Neither the name of the author nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
*****************************************************************************
**                            Includes                                     **
*****************************************************************************
*/
#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#include "rearrange_data.h"

/*
*****************************************************************************
**                   BLAS/Lapack calling macros                            **
*****************************************************************************
*/
#line 61

/* copy vector x into y */
extern void
FNAME(scopy)(int *n,
            float *sx, int *incx,
            float *sy, int *incy);

#if 0
/* complex conjugate */
extern void
FNAME(clacgv)(int *n, float *x, int *incx);
#endif

/*
*  =====================================================================
SUBROUTINE ?TRCHK( N, A, LDA, INFO )
*
*  -- BLAS/LAPACK-style routine --
*     Subhaneil Lahiri, January 2019
*
*     .. Scalar Arguments ..
 INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
 FLOAT             A( LDA, N )
*     ..
*
*  Purpose
*  =======
*
*  ?TRCHK checks if any of the diagonal elements of A is zero,
*  thus rendering the triangular matrix singular.
*
*  This method works for both upper and lower diagonal matrices.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input) FLOAT array, dimension (LDA,N)
*          The matrix A. Only its diagonal elements are accessed.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, A(i,i) is exactly zero; the matrix is
*                singular and its inverse cannot be computed.
*
*  =====================================================================
*/
void
FNAME(strchk)(int *n, float *a, int *lda, int *info) {
    float *diag_ptr = a;
    if (*n < 0) {
        /* check if N is legal */
        *info = -1;
        return;
    }
    if (*lda < *n) {
        /* check if LDA is legal (LDA < 0 => LDA < N) */
        *info = -3;
        return;
    }
    for (int i = 0; i < *n; i++, diag_ptr += *lda + 1) {
#if 0
        if (diag_ptr->r == 0 && diag_ptr->i == 0) {
            /* check if A(i,i) is legal */
#else
        if (*diag_ptr == 0) {
            /* check if A(i,i) is legal */
#endif
            *info = i + 1;
            return;
        }
    }
}


#line 61

/* copy vector x into y */
extern void
FNAME(dcopy)(int *n,
            double *sx, int *incx,
            double *sy, int *incy);

#if 0
/* complex conjugate */
extern void
FNAME(zlacgv)(int *n, double *x, int *incx);
#endif

/*
*  =====================================================================
SUBROUTINE ?TRCHK( N, A, LDA, INFO )
*
*  -- BLAS/LAPACK-style routine --
*     Subhaneil Lahiri, January 2019
*
*     .. Scalar Arguments ..
 INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
 DOUBLE             A( LDA, N )
*     ..
*
*  Purpose
*  =======
*
*  ?TRCHK checks if any of the diagonal elements of A is zero,
*  thus rendering the triangular matrix singular.
*
*  This method works for both upper and lower diagonal matrices.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input) DOUBLE array, dimension (LDA,N)
*          The matrix A. Only its diagonal elements are accessed.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, A(i,i) is exactly zero; the matrix is
*                singular and its inverse cannot be computed.
*
*  =====================================================================
*/
void
FNAME(dtrchk)(int *n, double *a, int *lda, int *info) {
    double *diag_ptr = a;
    if (*n < 0) {
        /* check if N is legal */
        *info = -1;
        return;
    }
    if (*lda < *n) {
        /* check if LDA is legal (LDA < 0 => LDA < N) */
        *info = -3;
        return;
    }
    for (int i = 0; i < *n; i++, diag_ptr += *lda + 1) {
#if 0
        if (diag_ptr->r == 0 && diag_ptr->i == 0) {
            /* check if A(i,i) is legal */
#else
        if (*diag_ptr == 0) {
            /* check if A(i,i) is legal */
#endif
            *info = i + 1;
            return;
        }
    }
}


#line 61

/* copy vector x into y */
extern void
FNAME(ccopy)(int *n,
            f2c_complex *sx, int *incx,
            f2c_complex *sy, int *incy);

#if 1
/* complex conjugate */
extern void
FNAME(clacgv)(int *n, f2c_complex *x, int *incx);
#endif

/*
*  =====================================================================
SUBROUTINE ?TRCHK( N, A, LDA, INFO )
*
*  -- BLAS/LAPACK-style routine --
*     Subhaneil Lahiri, January 2019
*
*     .. Scalar Arguments ..
 INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
 CFLOAT             A( LDA, N )
*     ..
*
*  Purpose
*  =======
*
*  ?TRCHK checks if any of the diagonal elements of A is zero,
*  thus rendering the triangular matrix singular.
*
*  This method works for both upper and lower diagonal matrices.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input) CFLOAT array, dimension (LDA,N)
*          The matrix A. Only its diagonal elements are accessed.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, A(i,i) is exactly zero; the matrix is
*                singular and its inverse cannot be computed.
*
*  =====================================================================
*/
void
FNAME(ctrchk)(int *n, f2c_complex *a, int *lda, int *info) {
    f2c_complex *diag_ptr = a;
    if (*n < 0) {
        /* check if N is legal */
        *info = -1;
        return;
    }
    if (*lda < *n) {
        /* check if LDA is legal (LDA < 0 => LDA < N) */
        *info = -3;
        return;
    }
    for (int i = 0; i < *n; i++, diag_ptr += *lda + 1) {
#if 1
        if (diag_ptr->r == 0 && diag_ptr->i == 0) {
            /* check if A(i,i) is legal */
#else
        if (*diag_ptr == 0) {
            /* check if A(i,i) is legal */
#endif
            *info = i + 1;
            return;
        }
    }
}


#line 61

/* copy vector x into y */
extern void
FNAME(zcopy)(int *n,
            f2c_doublecomplex *sx, int *incx,
            f2c_doublecomplex *sy, int *incy);

#if 1
/* complex conjugate */
extern void
FNAME(zlacgv)(int *n, f2c_doublecomplex *x, int *incx);
#endif

/*
*  =====================================================================
SUBROUTINE ?TRCHK( N, A, LDA, INFO )
*
*  -- BLAS/LAPACK-style routine --
*     Subhaneil Lahiri, January 2019
*
*     .. Scalar Arguments ..
 INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
 CDOUBLE             A( LDA, N )
*     ..
*
*  Purpose
*  =======
*
*  ?TRCHK checks if any of the diagonal elements of A is zero,
*  thus rendering the triangular matrix singular.
*
*  This method works for both upper and lower diagonal matrices.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input) CDOUBLE array, dimension (LDA,N)
*          The matrix A. Only its diagonal elements are accessed.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, A(i,i) is exactly zero; the matrix is
*                singular and its inverse cannot be computed.
*
*  =====================================================================
*/
void
FNAME(ztrchk)(int *n, f2c_doublecomplex *a, int *lda, int *info) {
    f2c_doublecomplex *diag_ptr = a;
    if (*n < 0) {
        /* check if N is legal */
        *info = -1;
        return;
    }
    if (*lda < *n) {
        /* check if LDA is legal (LDA < 0 => LDA < N) */
        *info = -3;
        return;
    }
    for (int i = 0; i < *n; i++, diag_ptr += *lda + 1) {
#if 1
        if (diag_ptr->r == 0 && diag_ptr->i == 0) {
            /* check if A(i,i) is legal */
#else
        if (*diag_ptr == 0) {
            /* check if A(i,i) is legal */
#endif
            *info = i + 1;
            return;
        }
    }
}



/*
*****************************************************************************
**                    Data rearrangement functions                         **
*****************************************************************************
*/

              /* rearranging of 2D matrices using blas */

#line 164

/*********************
*  Complex numbers   *
**********************/
/* Convert floating point to integer type */
fortran_int
FLOAT_real_int(fortran_real val)
{
#if 0
    return (fortran_int)val.r;
#else
    return (fortran_int)val;
#endif
}

/* Complex conjugate, if required */
static NPY_INLINE void
FLOAT_conj_vec(fortran_int len, float *dst, fortran_int stride,
                const LINEARIZE_DATA_t *data)
{
#if 0
    if (data->conj) {
        FNAME(clacgv)(&len, (void *)dst, &stride);
    }
#endif
}

/*********************
*  Copying matrices  *
**********************/
/* Copying full matrix from numpy to contiguous fortran */
void
linearize_FLOAT_matrix(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
    float *src = (float *) src_in;
    float *dst = (float *) dst_in;

    if (dst) {
        int i, j;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
                (fortran_int)(data->column_strides/sizeof(float));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(scopy)(&columns,
                              (void *)src, &column_strides,
                              (void *)dst, &one);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(scopy)(  &columns,
                                (void *)(src + (columns-1)*column_strides),
                                &column_strides,
                                (void *)dst, &one);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                for (j = 0; j < columns; ++j) {
                    memcpy((void *)(dst + j), (void *)src, sizeof(float));
                }
            }
            FLOAT_conj_vec(columns, dst, one, data);
            src += data->row_strides/sizeof(float);
            dst += data->output_lead_dim;
        }
    }
}

/* Copying full matrix from contiguous fortran to numpy */
void
delinearize_FLOAT_matrix(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
    float *src = (float *) src_in;
    float *dst = (float *) dst_in;

    if (src) {
        int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(float));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(scopy)(  &columns,
                                (void *)src, &one,
                                (void *)dst, &column_strides);
                FLOAT_conj_vec(columns, dst, column_strides, data);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy/lacgv assume dst points to first element in memory
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                float *dst_end = dst + (columns-1)*column_strides;
                FNAME(scopy)(  &columns,
                                (void *)src, &one,
                                (void *)dst_end, &column_strides);
                FLOAT_conj_vec(columns, dst_end, column_strides, data);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                if (columns > 0) {
                    memcpy((void *)dst, (void *)(src + (columns-1)), sizeof(float));
                    FLOAT_conj_vec(one, dst, one, data);
                }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(float);
        }
    }
}

/*
Copying upper triangular part of matrix from contiguous fortran to numpy

This function does not fill the lower triangle with zeros.
To do that, call zero_FLOAT_matrix first.
*/
void
delinearize_FLOAT_triu(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   float *src = (float *) src_in;
   float *dst = (float *) dst_in;

   if (src) {
       int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(float));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            fortran_int len = fortran_int_min(i + 1, columns);
            if (column_strides > 0) {
                FNAME(scopy)(  &len,
                                (void *)src, &one,
                                (void *)dst, &column_strides);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(scopy)(  &len,
                                (void *)src, &one,
                                (void *)(dst + (len-1)*column_strides),
                                &column_strides);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                if (columns > 0) {
                    memcpy((void *)dst, (void *)(src + (len-1)), sizeof(float));
                }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(float);
        }
    }
}

/*
Copying lower triangular part of matrix from contiguous fortran to numpy

This function does not fill the upper triangle with zeros, or set the diagonal.
To do that, call zero_FLOAT_matrix first. Unit diagonals can be set with
eye_FLOAT_matrix or delinearize_FLOAT_diag.
*/
void
delinearize_FLOAT_tril(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   float *src = (float *) src_in;
   float *dst = (float *) dst_in;

   if (src) {
       int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(float));
        fortran_int one = 1;
        for (i = 0; i < data->rows && i < columns - 1; i++) {
            fortran_int len = columns - i - 1;
            if (column_strides > 0) {
                FNAME(scopy)(  &len,
                                (void *)(src + i + 1), &one,
                                (void *)(dst + (i+1)*column_strides),
                                &column_strides);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(scopy)(  &len,
                                (void *)(src + i + 1), &one,
                                (void *)(dst + (columns-1)*column_strides),
                                &column_strides);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                memcpy((void *)dst, (void *)(src + (columns-1)), sizeof(float));
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(float);
        }
    }
}

/*
Copying diagonal part of matrix from contiguous fortran to numpy
*/
void
delinearize_FLOAT_diag(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   float *src = (float *) src_in;
   float *dst = (float *) dst_in;

   if (src) {
        int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int rows = (fortran_int)data->rows;
        fortran_int len = fortran_int_min(columns, rows);
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(float));
        fortran_int row_strides =
            (fortran_int)(data->row_strides/sizeof(float));
        fortran_int dst_strides = column_strides + row_strides;
        fortran_int src_strides = (fortran_int)(data->output_lead_dim + 1);

        if (dst_strides > 0) {
            FNAME(scopy)(  &len,
                            (void *)src, &src_strides,
                            (void *)dst, &dst_strides);
        }
        else if (dst_strides < 0) {
            /*
            * BLAS _copy assumes dst points to the first element in memory.
            * numpy points it at the first element of the array.
            * We have to compensate.
            */
            FNAME(scopy)(  &len,
                            (void *)src, &src_strides,
                            (void *)(dst + (len-1)*dst_strides),
                            &dst_strides);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            memcpy((void *)dst, (void *)(src + (len-1)*src_strides), sizeof(float));
        }
    }
}

/*********************
*  Filling matrices  *
**********************/
/* Fill a numpy matrix with NaNs */
void
nan_FLOAT_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    float *dst = (float *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(float);
    for (i = 0; i < data->rows; i++) {
        float *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = s_nan;
            cp += cs;
        }
        dst += data->row_strides/sizeof(float);
    }
}

/* Fill a numpy matrix with zeros */
void
zero_FLOAT_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    float *dst = (float *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(float);
    for (i = 0; i < data->rows; i++) {
        float *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = s_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(float);
    }
}

/* Fill upper triangle of a numpy matrix with NaN */
void
zero_FLOAT_triu(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    float *cp;
    npy_intp len;
    float *dst = (float *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(float);
    for (i = 0; i < data->rows; i++) {
        cp = dst;
        len = npy_int_min(i + 1, data->columns);
        for (j = 0; j < len; ++j) {
            *cp = s_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(float);
    }
}

/* Fill lower triangle of a numpy matrix with NaN */
void
zero_FLOAT_tril(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    float *cp;
    npy_intp len;
    float *dst = (float *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(float);

    for (i = 0; i < data->rows; i++) {
        cp = dst + (i + 1) * cs;
        len = npy_int_max(0, data->columns - i - 1);
        for (j = 0; j < len; ++j) {
            *cp = s_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(float);
    }
}

/*
Identity matrix: set diagonal elements to one.

This function does not fill the off-diagonals with zeros.
To do that, call zero_FLOAT_matrix first.
*/
void
eye_FLOAT_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    float *dst = (float *) dst_in;

    int i;
    ptrdiff_t cs = data->column_strides/sizeof(float);
    ptrdiff_t rs = data->row_strides/sizeof(float);

    for (i = 0; (i < data->rows) && (i < data->columns); i++) {
        *dst = s_one;
        dst += cs + rs;
    }
}

/*********************
*      Vectors       *
**********************/

/* Copying vector from numpy to contiguous fortran */
void
linearize_FLOAT_vec(void *dst_in,
                    const void *src_in,
                    const LINEARIZE_DATA_t *data)
{
    float *src = (float *) src_in;
    float *dst = (float *) dst_in;

    if (dst) {
        fortran_int len = (fortran_int)data->columns;
        fortran_int strides = (fortran_int)(data->column_strides/sizeof(float));
        fortran_int one = 1;
        if (strides > 0) {
            FNAME(scopy)(  &len,
                            (void *)src, &strides,
                            (void *)dst, &one);
        }
        else if (strides < 0) {
            /*
            * Lapack _copy assumes dst points to first element in memory
            * instead of first element of array & tries to compensate.
            * We have to undo that
            */
            FNAME(scopy)(  &len,
                            (void *)(src + (len-1)*strides), &strides,
                            (void *)dst, &one);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            int j;
            for (j = 0; j < len; ++j) {
                memcpy((void *)(dst + j), (void *)src, sizeof(float));
            }
            FLOAT_conj_vec(len, dst, one, data);
        }
    }
}

/* Copying vector from contiguous fortran to numpy */
void
delinearize_FLOAT_vec(void *dst_in,
                     const void *src_in,
                     const LINEARIZE_DATA_t *data)
{
    float *src = (float *) src_in;
    float *dst = (float *) dst_in;

    if (dst) {
        fortran_int len = (fortran_int)data->columns;
        fortran_int strides = (fortran_int)(data->column_strides/sizeof(float));
        fortran_int one = 1;
        if (strides > 0) {
            FNAME(scopy)(  &len,
                            (void *)src, &one,
                            (void *)dst, &strides);
            FLOAT_conj_vec(len, dst, strides, data);
        }
        else if (strides < 0) {
            /*
            * BLAS _copy assumes dst points to the first element in memory.
            * numpy points it at the first element of the array.
            * We have to compensate.
            */
            FNAME(scopy)(  &len,
                            (void *)src, &one,
                            (void *)(dst + (len-1)*strides), &strides);
            FLOAT_conj_vec(len, dst + (len-1)*strides, strides, data);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            if (len > 0) {
                int j;
                for (j = 0; j < len; ++j) {
                    memcpy((void *)dst, (void *)(src + j), sizeof(float));
                }
                FLOAT_conj_vec(one, dst, strides, data);
            }
        }
    }
}

/* Fill a numpy vector with NaNs */
void
nan_FLOAT_vec(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    float *dst = (float *) dst_in;

    int j;
    ptrdiff_t cs = data->column_strides/sizeof(float);
    for (j = 0; j < data->columns; ++j) {
        *dst = s_nan;
        dst += cs;
    }
}


/************************
*  Triangular matrices  *
*************************/

/*
Copying upper/lower triangular part of matrices from contiguous fortran to numpy

This function does fill the other triangle with zeros and copies the diagonal.
*/
void
delinearize_FLOAT_trilu(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data,
                        int lower)
{
    if (lower) {
        /* Zero out L */
        zero_FLOAT_triu(dst_in, data);
        /* Copy triangular L from buffer */
        delinearize_FLOAT_tril(dst_in, src_in, data);
        /* Copy diagonal of L from buffer */
        delinearize_FLOAT_diag(dst_in, src_in, data);
    } else {
        /* Zero out R */
        zero_FLOAT_tril(dst_in, data);
        /* Copy triangular R from buffer */            
        delinearize_FLOAT_triu(dst_in, src_in, data);
    }
}



#line 164

/*********************
*  Complex numbers   *
**********************/
/* Convert floating point to integer type */
fortran_int
DOUBLE_real_int(fortran_doublereal val)
{
#if 0
    return (fortran_int)val.r;
#else
    return (fortran_int)val;
#endif
}

/* Complex conjugate, if required */
static NPY_INLINE void
DOUBLE_conj_vec(fortran_int len, double *dst, fortran_int stride,
                const LINEARIZE_DATA_t *data)
{
#if 0
    if (data->conj) {
        FNAME(zlacgv)(&len, (void *)dst, &stride);
    }
#endif
}

/*********************
*  Copying matrices  *
**********************/
/* Copying full matrix from numpy to contiguous fortran */
void
linearize_DOUBLE_matrix(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
    double *src = (double *) src_in;
    double *dst = (double *) dst_in;

    if (dst) {
        int i, j;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
                (fortran_int)(data->column_strides/sizeof(double));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(dcopy)(&columns,
                              (void *)src, &column_strides,
                              (void *)dst, &one);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(dcopy)(  &columns,
                                (void *)(src + (columns-1)*column_strides),
                                &column_strides,
                                (void *)dst, &one);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                for (j = 0; j < columns; ++j) {
                    memcpy((void *)(dst + j), (void *)src, sizeof(double));
                }
            }
            DOUBLE_conj_vec(columns, dst, one, data);
            src += data->row_strides/sizeof(double);
            dst += data->output_lead_dim;
        }
    }
}

/* Copying full matrix from contiguous fortran to numpy */
void
delinearize_DOUBLE_matrix(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
    double *src = (double *) src_in;
    double *dst = (double *) dst_in;

    if (src) {
        int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(double));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(dcopy)(  &columns,
                                (void *)src, &one,
                                (void *)dst, &column_strides);
                DOUBLE_conj_vec(columns, dst, column_strides, data);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy/lacgv assume dst points to first element in memory
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                double *dst_end = dst + (columns-1)*column_strides;
                FNAME(dcopy)(  &columns,
                                (void *)src, &one,
                                (void *)dst_end, &column_strides);
                DOUBLE_conj_vec(columns, dst_end, column_strides, data);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                if (columns > 0) {
                    memcpy((void *)dst, (void *)(src + (columns-1)), sizeof(double));
                    DOUBLE_conj_vec(one, dst, one, data);
                }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(double);
        }
    }
}

/*
Copying upper triangular part of matrix from contiguous fortran to numpy

This function does not fill the lower triangle with zeros.
To do that, call zero_DOUBLE_matrix first.
*/
void
delinearize_DOUBLE_triu(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   double *src = (double *) src_in;
   double *dst = (double *) dst_in;

   if (src) {
       int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(double));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            fortran_int len = fortran_int_min(i + 1, columns);
            if (column_strides > 0) {
                FNAME(dcopy)(  &len,
                                (void *)src, &one,
                                (void *)dst, &column_strides);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(dcopy)(  &len,
                                (void *)src, &one,
                                (void *)(dst + (len-1)*column_strides),
                                &column_strides);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                if (columns > 0) {
                    memcpy((void *)dst, (void *)(src + (len-1)), sizeof(double));
                }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(double);
        }
    }
}

/*
Copying lower triangular part of matrix from contiguous fortran to numpy

This function does not fill the upper triangle with zeros, or set the diagonal.
To do that, call zero_DOUBLE_matrix first. Unit diagonals can be set with
eye_DOUBLE_matrix or delinearize_DOUBLE_diag.
*/
void
delinearize_DOUBLE_tril(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   double *src = (double *) src_in;
   double *dst = (double *) dst_in;

   if (src) {
       int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(double));
        fortran_int one = 1;
        for (i = 0; i < data->rows && i < columns - 1; i++) {
            fortran_int len = columns - i - 1;
            if (column_strides > 0) {
                FNAME(dcopy)(  &len,
                                (void *)(src + i + 1), &one,
                                (void *)(dst + (i+1)*column_strides),
                                &column_strides);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(dcopy)(  &len,
                                (void *)(src + i + 1), &one,
                                (void *)(dst + (columns-1)*column_strides),
                                &column_strides);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                memcpy((void *)dst, (void *)(src + (columns-1)), sizeof(double));
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(double);
        }
    }
}

/*
Copying diagonal part of matrix from contiguous fortran to numpy
*/
void
delinearize_DOUBLE_diag(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   double *src = (double *) src_in;
   double *dst = (double *) dst_in;

   if (src) {
        int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int rows = (fortran_int)data->rows;
        fortran_int len = fortran_int_min(columns, rows);
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(double));
        fortran_int row_strides =
            (fortran_int)(data->row_strides/sizeof(double));
        fortran_int dst_strides = column_strides + row_strides;
        fortran_int src_strides = (fortran_int)(data->output_lead_dim + 1);

        if (dst_strides > 0) {
            FNAME(dcopy)(  &len,
                            (void *)src, &src_strides,
                            (void *)dst, &dst_strides);
        }
        else if (dst_strides < 0) {
            /*
            * BLAS _copy assumes dst points to the first element in memory.
            * numpy points it at the first element of the array.
            * We have to compensate.
            */
            FNAME(dcopy)(  &len,
                            (void *)src, &src_strides,
                            (void *)(dst + (len-1)*dst_strides),
                            &dst_strides);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            memcpy((void *)dst, (void *)(src + (len-1)*src_strides), sizeof(double));
        }
    }
}

/*********************
*  Filling matrices  *
**********************/
/* Fill a numpy matrix with NaNs */
void
nan_DOUBLE_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    double *dst = (double *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(double);
    for (i = 0; i < data->rows; i++) {
        double *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = d_nan;
            cp += cs;
        }
        dst += data->row_strides/sizeof(double);
    }
}

/* Fill a numpy matrix with zeros */
void
zero_DOUBLE_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    double *dst = (double *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(double);
    for (i = 0; i < data->rows; i++) {
        double *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = d_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(double);
    }
}

/* Fill upper triangle of a numpy matrix with NaN */
void
zero_DOUBLE_triu(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    double *cp;
    npy_intp len;
    double *dst = (double *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(double);
    for (i = 0; i < data->rows; i++) {
        cp = dst;
        len = npy_int_min(i + 1, data->columns);
        for (j = 0; j < len; ++j) {
            *cp = d_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(double);
    }
}

/* Fill lower triangle of a numpy matrix with NaN */
void
zero_DOUBLE_tril(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    double *cp;
    npy_intp len;
    double *dst = (double *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(double);

    for (i = 0; i < data->rows; i++) {
        cp = dst + (i + 1) * cs;
        len = npy_int_max(0, data->columns - i - 1);
        for (j = 0; j < len; ++j) {
            *cp = d_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(double);
    }
}

/*
Identity matrix: set diagonal elements to one.

This function does not fill the off-diagonals with zeros.
To do that, call zero_DOUBLE_matrix first.
*/
void
eye_DOUBLE_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    double *dst = (double *) dst_in;

    int i;
    ptrdiff_t cs = data->column_strides/sizeof(double);
    ptrdiff_t rs = data->row_strides/sizeof(double);

    for (i = 0; (i < data->rows) && (i < data->columns); i++) {
        *dst = d_one;
        dst += cs + rs;
    }
}

/*********************
*      Vectors       *
**********************/

/* Copying vector from numpy to contiguous fortran */
void
linearize_DOUBLE_vec(void *dst_in,
                    const void *src_in,
                    const LINEARIZE_DATA_t *data)
{
    double *src = (double *) src_in;
    double *dst = (double *) dst_in;

    if (dst) {
        fortran_int len = (fortran_int)data->columns;
        fortran_int strides = (fortran_int)(data->column_strides/sizeof(double));
        fortran_int one = 1;
        if (strides > 0) {
            FNAME(dcopy)(  &len,
                            (void *)src, &strides,
                            (void *)dst, &one);
        }
        else if (strides < 0) {
            /*
            * Lapack _copy assumes dst points to first element in memory
            * instead of first element of array & tries to compensate.
            * We have to undo that
            */
            FNAME(dcopy)(  &len,
                            (void *)(src + (len-1)*strides), &strides,
                            (void *)dst, &one);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            int j;
            for (j = 0; j < len; ++j) {
                memcpy((void *)(dst + j), (void *)src, sizeof(double));
            }
            DOUBLE_conj_vec(len, dst, one, data);
        }
    }
}

/* Copying vector from contiguous fortran to numpy */
void
delinearize_DOUBLE_vec(void *dst_in,
                     const void *src_in,
                     const LINEARIZE_DATA_t *data)
{
    double *src = (double *) src_in;
    double *dst = (double *) dst_in;

    if (dst) {
        fortran_int len = (fortran_int)data->columns;
        fortran_int strides = (fortran_int)(data->column_strides/sizeof(double));
        fortran_int one = 1;
        if (strides > 0) {
            FNAME(dcopy)(  &len,
                            (void *)src, &one,
                            (void *)dst, &strides);
            DOUBLE_conj_vec(len, dst, strides, data);
        }
        else if (strides < 0) {
            /*
            * BLAS _copy assumes dst points to the first element in memory.
            * numpy points it at the first element of the array.
            * We have to compensate.
            */
            FNAME(dcopy)(  &len,
                            (void *)src, &one,
                            (void *)(dst + (len-1)*strides), &strides);
            DOUBLE_conj_vec(len, dst + (len-1)*strides, strides, data);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            if (len > 0) {
                int j;
                for (j = 0; j < len; ++j) {
                    memcpy((void *)dst, (void *)(src + j), sizeof(double));
                }
                DOUBLE_conj_vec(one, dst, strides, data);
            }
        }
    }
}

/* Fill a numpy vector with NaNs */
void
nan_DOUBLE_vec(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    double *dst = (double *) dst_in;

    int j;
    ptrdiff_t cs = data->column_strides/sizeof(double);
    for (j = 0; j < data->columns; ++j) {
        *dst = d_nan;
        dst += cs;
    }
}


/************************
*  Triangular matrices  *
*************************/

/*
Copying upper/lower triangular part of matrices from contiguous fortran to numpy

This function does fill the other triangle with zeros and copies the diagonal.
*/
void
delinearize_DOUBLE_trilu(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data,
                        int lower)
{
    if (lower) {
        /* Zero out L */
        zero_DOUBLE_triu(dst_in, data);
        /* Copy triangular L from buffer */
        delinearize_DOUBLE_tril(dst_in, src_in, data);
        /* Copy diagonal of L from buffer */
        delinearize_DOUBLE_diag(dst_in, src_in, data);
    } else {
        /* Zero out R */
        zero_DOUBLE_tril(dst_in, data);
        /* Copy triangular R from buffer */            
        delinearize_DOUBLE_triu(dst_in, src_in, data);
    }
}



#line 164

/*********************
*  Complex numbers   *
**********************/
/* Convert floating point to integer type */
fortran_int
CFLOAT_real_int(fortran_complex val)
{
#if 1
    return (fortran_int)val.r;
#else
    return (fortran_int)val;
#endif
}

/* Complex conjugate, if required */
static NPY_INLINE void
CFLOAT_conj_vec(fortran_int len, COMPLEX_t *dst, fortran_int stride,
                const LINEARIZE_DATA_t *data)
{
#if 1
    if (data->conj) {
        FNAME(clacgv)(&len, (void *)dst, &stride);
    }
#endif
}

/*********************
*  Copying matrices  *
**********************/
/* Copying full matrix from numpy to contiguous fortran */
void
linearize_CFLOAT_matrix(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
    COMPLEX_t *src = (COMPLEX_t *) src_in;
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    if (dst) {
        int i, j;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
                (fortran_int)(data->column_strides/sizeof(COMPLEX_t));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(ccopy)(&columns,
                              (void *)src, &column_strides,
                              (void *)dst, &one);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(ccopy)(  &columns,
                                (void *)(src + (columns-1)*column_strides),
                                &column_strides,
                                (void *)dst, &one);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                for (j = 0; j < columns; ++j) {
                    memcpy((void *)(dst + j), (void *)src, sizeof(COMPLEX_t));
                }
            }
            CFLOAT_conj_vec(columns, dst, one, data);
            src += data->row_strides/sizeof(COMPLEX_t);
            dst += data->output_lead_dim;
        }
    }
}

/* Copying full matrix from contiguous fortran to numpy */
void
delinearize_CFLOAT_matrix(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
    COMPLEX_t *src = (COMPLEX_t *) src_in;
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    if (src) {
        int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(COMPLEX_t));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(ccopy)(  &columns,
                                (void *)src, &one,
                                (void *)dst, &column_strides);
                CFLOAT_conj_vec(columns, dst, column_strides, data);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy/lacgv assume dst points to first element in memory
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                COMPLEX_t *dst_end = dst + (columns-1)*column_strides;
                FNAME(ccopy)(  &columns,
                                (void *)src, &one,
                                (void *)dst_end, &column_strides);
                CFLOAT_conj_vec(columns, dst_end, column_strides, data);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                if (columns > 0) {
                    memcpy((void *)dst, (void *)(src + (columns-1)), sizeof(COMPLEX_t));
                    CFLOAT_conj_vec(one, dst, one, data);
                }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(COMPLEX_t);
        }
    }
}

/*
Copying upper triangular part of matrix from contiguous fortran to numpy

This function does not fill the lower triangle with zeros.
To do that, call zero_CFLOAT_matrix first.
*/
void
delinearize_CFLOAT_triu(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   COMPLEX_t *src = (COMPLEX_t *) src_in;
   COMPLEX_t *dst = (COMPLEX_t *) dst_in;

   if (src) {
       int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(COMPLEX_t));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            fortran_int len = fortran_int_min(i + 1, columns);
            if (column_strides > 0) {
                FNAME(ccopy)(  &len,
                                (void *)src, &one,
                                (void *)dst, &column_strides);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(ccopy)(  &len,
                                (void *)src, &one,
                                (void *)(dst + (len-1)*column_strides),
                                &column_strides);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                if (columns > 0) {
                    memcpy((void *)dst, (void *)(src + (len-1)), sizeof(COMPLEX_t));
                }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(COMPLEX_t);
        }
    }
}

/*
Copying lower triangular part of matrix from contiguous fortran to numpy

This function does not fill the upper triangle with zeros, or set the diagonal.
To do that, call zero_CFLOAT_matrix first. Unit diagonals can be set with
eye_CFLOAT_matrix or delinearize_CFLOAT_diag.
*/
void
delinearize_CFLOAT_tril(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   COMPLEX_t *src = (COMPLEX_t *) src_in;
   COMPLEX_t *dst = (COMPLEX_t *) dst_in;

   if (src) {
       int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(COMPLEX_t));
        fortran_int one = 1;
        for (i = 0; i < data->rows && i < columns - 1; i++) {
            fortran_int len = columns - i - 1;
            if (column_strides > 0) {
                FNAME(ccopy)(  &len,
                                (void *)(src + i + 1), &one,
                                (void *)(dst + (i+1)*column_strides),
                                &column_strides);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(ccopy)(  &len,
                                (void *)(src + i + 1), &one,
                                (void *)(dst + (columns-1)*column_strides),
                                &column_strides);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                memcpy((void *)dst, (void *)(src + (columns-1)), sizeof(COMPLEX_t));
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(COMPLEX_t);
        }
    }
}

/*
Copying diagonal part of matrix from contiguous fortran to numpy
*/
void
delinearize_CFLOAT_diag(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   COMPLEX_t *src = (COMPLEX_t *) src_in;
   COMPLEX_t *dst = (COMPLEX_t *) dst_in;

   if (src) {
        int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int rows = (fortran_int)data->rows;
        fortran_int len = fortran_int_min(columns, rows);
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(COMPLEX_t));
        fortran_int row_strides =
            (fortran_int)(data->row_strides/sizeof(COMPLEX_t));
        fortran_int dst_strides = column_strides + row_strides;
        fortran_int src_strides = (fortran_int)(data->output_lead_dim + 1);

        if (dst_strides > 0) {
            FNAME(ccopy)(  &len,
                            (void *)src, &src_strides,
                            (void *)dst, &dst_strides);
        }
        else if (dst_strides < 0) {
            /*
            * BLAS _copy assumes dst points to the first element in memory.
            * numpy points it at the first element of the array.
            * We have to compensate.
            */
            FNAME(ccopy)(  &len,
                            (void *)src, &src_strides,
                            (void *)(dst + (len-1)*dst_strides),
                            &dst_strides);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            memcpy((void *)dst, (void *)(src + (len-1)*src_strides), sizeof(COMPLEX_t));
        }
    }
}

/*********************
*  Filling matrices  *
**********************/
/* Fill a numpy matrix with NaNs */
void
nan_CFLOAT_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(COMPLEX_t);
    for (i = 0; i < data->rows; i++) {
        COMPLEX_t *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = c_nan;
            cp += cs;
        }
        dst += data->row_strides/sizeof(COMPLEX_t);
    }
}

/* Fill a numpy matrix with zeros */
void
zero_CFLOAT_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(COMPLEX_t);
    for (i = 0; i < data->rows; i++) {
        COMPLEX_t *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = c_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(COMPLEX_t);
    }
}

/* Fill upper triangle of a numpy matrix with NaN */
void
zero_CFLOAT_triu(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    COMPLEX_t *cp;
    npy_intp len;
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(COMPLEX_t);
    for (i = 0; i < data->rows; i++) {
        cp = dst;
        len = npy_int_min(i + 1, data->columns);
        for (j = 0; j < len; ++j) {
            *cp = c_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(COMPLEX_t);
    }
}

/* Fill lower triangle of a numpy matrix with NaN */
void
zero_CFLOAT_tril(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    COMPLEX_t *cp;
    npy_intp len;
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(COMPLEX_t);

    for (i = 0; i < data->rows; i++) {
        cp = dst + (i + 1) * cs;
        len = npy_int_max(0, data->columns - i - 1);
        for (j = 0; j < len; ++j) {
            *cp = c_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(COMPLEX_t);
    }
}

/*
Identity matrix: set diagonal elements to one.

This function does not fill the off-diagonals with zeros.
To do that, call zero_CFLOAT_matrix first.
*/
void
eye_CFLOAT_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    int i;
    ptrdiff_t cs = data->column_strides/sizeof(COMPLEX_t);
    ptrdiff_t rs = data->row_strides/sizeof(COMPLEX_t);

    for (i = 0; (i < data->rows) && (i < data->columns); i++) {
        *dst = c_one;
        dst += cs + rs;
    }
}

/*********************
*      Vectors       *
**********************/

/* Copying vector from numpy to contiguous fortran */
void
linearize_CFLOAT_vec(void *dst_in,
                    const void *src_in,
                    const LINEARIZE_DATA_t *data)
{
    COMPLEX_t *src = (COMPLEX_t *) src_in;
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    if (dst) {
        fortran_int len = (fortran_int)data->columns;
        fortran_int strides = (fortran_int)(data->column_strides/sizeof(COMPLEX_t));
        fortran_int one = 1;
        if (strides > 0) {
            FNAME(ccopy)(  &len,
                            (void *)src, &strides,
                            (void *)dst, &one);
        }
        else if (strides < 0) {
            /*
            * Lapack _copy assumes dst points to first element in memory
            * instead of first element of array & tries to compensate.
            * We have to undo that
            */
            FNAME(ccopy)(  &len,
                            (void *)(src + (len-1)*strides), &strides,
                            (void *)dst, &one);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            int j;
            for (j = 0; j < len; ++j) {
                memcpy((void *)(dst + j), (void *)src, sizeof(COMPLEX_t));
            }
            CFLOAT_conj_vec(len, dst, one, data);
        }
    }
}

/* Copying vector from contiguous fortran to numpy */
void
delinearize_CFLOAT_vec(void *dst_in,
                     const void *src_in,
                     const LINEARIZE_DATA_t *data)
{
    COMPLEX_t *src = (COMPLEX_t *) src_in;
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    if (dst) {
        fortran_int len = (fortran_int)data->columns;
        fortran_int strides = (fortran_int)(data->column_strides/sizeof(COMPLEX_t));
        fortran_int one = 1;
        if (strides > 0) {
            FNAME(ccopy)(  &len,
                            (void *)src, &one,
                            (void *)dst, &strides);
            CFLOAT_conj_vec(len, dst, strides, data);
        }
        else if (strides < 0) {
            /*
            * BLAS _copy assumes dst points to the first element in memory.
            * numpy points it at the first element of the array.
            * We have to compensate.
            */
            FNAME(ccopy)(  &len,
                            (void *)src, &one,
                            (void *)(dst + (len-1)*strides), &strides);
            CFLOAT_conj_vec(len, dst + (len-1)*strides, strides, data);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            if (len > 0) {
                int j;
                for (j = 0; j < len; ++j) {
                    memcpy((void *)dst, (void *)(src + j), sizeof(COMPLEX_t));
                }
                CFLOAT_conj_vec(one, dst, strides, data);
            }
        }
    }
}

/* Fill a numpy vector with NaNs */
void
nan_CFLOAT_vec(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    COMPLEX_t *dst = (COMPLEX_t *) dst_in;

    int j;
    ptrdiff_t cs = data->column_strides/sizeof(COMPLEX_t);
    for (j = 0; j < data->columns; ++j) {
        *dst = c_nan;
        dst += cs;
    }
}


/************************
*  Triangular matrices  *
*************************/

/*
Copying upper/lower triangular part of matrices from contiguous fortran to numpy

This function does fill the other triangle with zeros and copies the diagonal.
*/
void
delinearize_CFLOAT_trilu(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data,
                        int lower)
{
    if (lower) {
        /* Zero out L */
        zero_CFLOAT_triu(dst_in, data);
        /* Copy triangular L from buffer */
        delinearize_CFLOAT_tril(dst_in, src_in, data);
        /* Copy diagonal of L from buffer */
        delinearize_CFLOAT_diag(dst_in, src_in, data);
    } else {
        /* Zero out R */
        zero_CFLOAT_tril(dst_in, data);
        /* Copy triangular R from buffer */            
        delinearize_CFLOAT_triu(dst_in, src_in, data);
    }
}



#line 164

/*********************
*  Complex numbers   *
**********************/
/* Convert floating point to integer type */
fortran_int
CDOUBLE_real_int(fortran_doublecomplex val)
{
#if 1
    return (fortran_int)val.r;
#else
    return (fortran_int)val;
#endif
}

/* Complex conjugate, if required */
static NPY_INLINE void
CDOUBLE_conj_vec(fortran_int len, DOUBLECOMPLEX_t *dst, fortran_int stride,
                const LINEARIZE_DATA_t *data)
{
#if 1
    if (data->conj) {
        FNAME(zlacgv)(&len, (void *)dst, &stride);
    }
#endif
}

/*********************
*  Copying matrices  *
**********************/
/* Copying full matrix from numpy to contiguous fortran */
void
linearize_CDOUBLE_matrix(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
    DOUBLECOMPLEX_t *src = (DOUBLECOMPLEX_t *) src_in;
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    if (dst) {
        int i, j;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
                (fortran_int)(data->column_strides/sizeof(DOUBLECOMPLEX_t));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(zcopy)(&columns,
                              (void *)src, &column_strides,
                              (void *)dst, &one);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(zcopy)(  &columns,
                                (void *)(src + (columns-1)*column_strides),
                                &column_strides,
                                (void *)dst, &one);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                for (j = 0; j < columns; ++j) {
                    memcpy((void *)(dst + j), (void *)src, sizeof(DOUBLECOMPLEX_t));
                }
            }
            CDOUBLE_conj_vec(columns, dst, one, data);
            src += data->row_strides/sizeof(DOUBLECOMPLEX_t);
            dst += data->output_lead_dim;
        }
    }
}

/* Copying full matrix from contiguous fortran to numpy */
void
delinearize_CDOUBLE_matrix(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
    DOUBLECOMPLEX_t *src = (DOUBLECOMPLEX_t *) src_in;
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    if (src) {
        int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(DOUBLECOMPLEX_t));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(zcopy)(  &columns,
                                (void *)src, &one,
                                (void *)dst, &column_strides);
                CDOUBLE_conj_vec(columns, dst, column_strides, data);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy/lacgv assume dst points to first element in memory
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                DOUBLECOMPLEX_t *dst_end = dst + (columns-1)*column_strides;
                FNAME(zcopy)(  &columns,
                                (void *)src, &one,
                                (void *)dst_end, &column_strides);
                CDOUBLE_conj_vec(columns, dst_end, column_strides, data);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                if (columns > 0) {
                    memcpy((void *)dst, (void *)(src + (columns-1)), sizeof(DOUBLECOMPLEX_t));
                    CDOUBLE_conj_vec(one, dst, one, data);
                }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(DOUBLECOMPLEX_t);
        }
    }
}

/*
Copying upper triangular part of matrix from contiguous fortran to numpy

This function does not fill the lower triangle with zeros.
To do that, call zero_CDOUBLE_matrix first.
*/
void
delinearize_CDOUBLE_triu(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   DOUBLECOMPLEX_t *src = (DOUBLECOMPLEX_t *) src_in;
   DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

   if (src) {
       int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(DOUBLECOMPLEX_t));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            fortran_int len = fortran_int_min(i + 1, columns);
            if (column_strides > 0) {
                FNAME(zcopy)(  &len,
                                (void *)src, &one,
                                (void *)dst, &column_strides);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(zcopy)(  &len,
                                (void *)src, &one,
                                (void *)(dst + (len-1)*column_strides),
                                &column_strides);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                if (columns > 0) {
                    memcpy((void *)dst, (void *)(src + (len-1)), sizeof(DOUBLECOMPLEX_t));
                }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(DOUBLECOMPLEX_t);
        }
    }
}

/*
Copying lower triangular part of matrix from contiguous fortran to numpy

This function does not fill the upper triangle with zeros, or set the diagonal.
To do that, call zero_CDOUBLE_matrix first. Unit diagonals can be set with
eye_CDOUBLE_matrix or delinearize_CDOUBLE_diag.
*/
void
delinearize_CDOUBLE_tril(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   DOUBLECOMPLEX_t *src = (DOUBLECOMPLEX_t *) src_in;
   DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

   if (src) {
       int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(DOUBLECOMPLEX_t));
        fortran_int one = 1;
        for (i = 0; i < data->rows && i < columns - 1; i++) {
            fortran_int len = columns - i - 1;
            if (column_strides > 0) {
                FNAME(zcopy)(  &len,
                                (void *)(src + i + 1), &one,
                                (void *)(dst + (i+1)*column_strides),
                                &column_strides);
            }
            else if (column_strides < 0) {
                /*
                * BLAS _copy assumes dst points to the first element in memory.
                * numpy points it at the first element of the array.
                * We have to compensate.
                */
                FNAME(zcopy)(  &len,
                                (void *)(src + i + 1), &one,
                                (void *)(dst + (columns-1)*column_strides),
                                &column_strides);
            }
            else {
                /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                memcpy((void *)dst, (void *)(src + (columns-1)), sizeof(DOUBLECOMPLEX_t));
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(DOUBLECOMPLEX_t);
        }
    }
}

/*
Copying diagonal part of matrix from contiguous fortran to numpy
*/
void
delinearize_CDOUBLE_diag(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   DOUBLECOMPLEX_t *src = (DOUBLECOMPLEX_t *) src_in;
   DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

   if (src) {
        int i;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int rows = (fortran_int)data->rows;
        fortran_int len = fortran_int_min(columns, rows);
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(DOUBLECOMPLEX_t));
        fortran_int row_strides =
            (fortran_int)(data->row_strides/sizeof(DOUBLECOMPLEX_t));
        fortran_int dst_strides = column_strides + row_strides;
        fortran_int src_strides = (fortran_int)(data->output_lead_dim + 1);

        if (dst_strides > 0) {
            FNAME(zcopy)(  &len,
                            (void *)src, &src_strides,
                            (void *)dst, &dst_strides);
        }
        else if (dst_strides < 0) {
            /*
            * BLAS _copy assumes dst points to the first element in memory.
            * numpy points it at the first element of the array.
            * We have to compensate.
            */
            FNAME(zcopy)(  &len,
                            (void *)src, &src_strides,
                            (void *)(dst + (len-1)*dst_strides),
                            &dst_strides);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            memcpy((void *)dst, (void *)(src + (len-1)*src_strides), sizeof(DOUBLECOMPLEX_t));
        }
    }
}

/*********************
*  Filling matrices  *
**********************/
/* Fill a numpy matrix with NaNs */
void
nan_CDOUBLE_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(DOUBLECOMPLEX_t);
    for (i = 0; i < data->rows; i++) {
        DOUBLECOMPLEX_t *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = z_nan;
            cp += cs;
        }
        dst += data->row_strides/sizeof(DOUBLECOMPLEX_t);
    }
}

/* Fill a numpy matrix with zeros */
void
zero_CDOUBLE_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(DOUBLECOMPLEX_t);
    for (i = 0; i < data->rows; i++) {
        DOUBLECOMPLEX_t *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = z_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(DOUBLECOMPLEX_t);
    }
}

/* Fill upper triangle of a numpy matrix with NaN */
void
zero_CDOUBLE_triu(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    DOUBLECOMPLEX_t *cp;
    npy_intp len;
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(DOUBLECOMPLEX_t);
    for (i = 0; i < data->rows; i++) {
        cp = dst;
        len = npy_int_min(i + 1, data->columns);
        for (j = 0; j < len; ++j) {
            *cp = z_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(DOUBLECOMPLEX_t);
    }
}

/* Fill lower triangle of a numpy matrix with NaN */
void
zero_CDOUBLE_tril(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    DOUBLECOMPLEX_t *cp;
    npy_intp len;
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(DOUBLECOMPLEX_t);

    for (i = 0; i < data->rows; i++) {
        cp = dst + (i + 1) * cs;
        len = npy_int_max(0, data->columns - i - 1);
        for (j = 0; j < len; ++j) {
            *cp = z_zero;
            cp += cs;
        }
        dst += data->row_strides/sizeof(DOUBLECOMPLEX_t);
    }
}

/*
Identity matrix: set diagonal elements to one.

This function does not fill the off-diagonals with zeros.
To do that, call zero_CDOUBLE_matrix first.
*/
void
eye_CDOUBLE_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    int i;
    ptrdiff_t cs = data->column_strides/sizeof(DOUBLECOMPLEX_t);
    ptrdiff_t rs = data->row_strides/sizeof(DOUBLECOMPLEX_t);

    for (i = 0; (i < data->rows) && (i < data->columns); i++) {
        *dst = z_one;
        dst += cs + rs;
    }
}

/*********************
*      Vectors       *
**********************/

/* Copying vector from numpy to contiguous fortran */
void
linearize_CDOUBLE_vec(void *dst_in,
                    const void *src_in,
                    const LINEARIZE_DATA_t *data)
{
    DOUBLECOMPLEX_t *src = (DOUBLECOMPLEX_t *) src_in;
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    if (dst) {
        fortran_int len = (fortran_int)data->columns;
        fortran_int strides = (fortran_int)(data->column_strides/sizeof(DOUBLECOMPLEX_t));
        fortran_int one = 1;
        if (strides > 0) {
            FNAME(zcopy)(  &len,
                            (void *)src, &strides,
                            (void *)dst, &one);
        }
        else if (strides < 0) {
            /*
            * Lapack _copy assumes dst points to first element in memory
            * instead of first element of array & tries to compensate.
            * We have to undo that
            */
            FNAME(zcopy)(  &len,
                            (void *)(src + (len-1)*strides), &strides,
                            (void *)dst, &one);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            int j;
            for (j = 0; j < len; ++j) {
                memcpy((void *)(dst + j), (void *)src, sizeof(DOUBLECOMPLEX_t));
            }
            CDOUBLE_conj_vec(len, dst, one, data);
        }
    }
}

/* Copying vector from contiguous fortran to numpy */
void
delinearize_CDOUBLE_vec(void *dst_in,
                     const void *src_in,
                     const LINEARIZE_DATA_t *data)
{
    DOUBLECOMPLEX_t *src = (DOUBLECOMPLEX_t *) src_in;
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    if (dst) {
        fortran_int len = (fortran_int)data->columns;
        fortran_int strides = (fortran_int)(data->column_strides/sizeof(DOUBLECOMPLEX_t));
        fortran_int one = 1;
        if (strides > 0) {
            FNAME(zcopy)(  &len,
                            (void *)src, &one,
                            (void *)dst, &strides);
            CDOUBLE_conj_vec(len, dst, strides, data);
        }
        else if (strides < 0) {
            /*
            * BLAS _copy assumes dst points to the first element in memory.
            * numpy points it at the first element of the array.
            * We have to compensate.
            */
            FNAME(zcopy)(  &len,
                            (void *)src, &one,
                            (void *)(dst + (len-1)*strides), &strides);
            CDOUBLE_conj_vec(len, dst + (len-1)*strides, strides, data);
        }
        else {
            /*
            * Zero stride has undefined behavior in some BLAS
            * implementations (e.g. OSX Accelerate), so do it
            * manually
            */
            if (len > 0) {
                int j;
                for (j = 0; j < len; ++j) {
                    memcpy((void *)dst, (void *)(src + j), sizeof(DOUBLECOMPLEX_t));
                }
                CDOUBLE_conj_vec(one, dst, strides, data);
            }
        }
    }
}

/* Fill a numpy vector with NaNs */
void
nan_CDOUBLE_vec(void *dst_in, const LINEARIZE_DATA_t* data)
{
    init_constants();
    DOUBLECOMPLEX_t *dst = (DOUBLECOMPLEX_t *) dst_in;

    int j;
    ptrdiff_t cs = data->column_strides/sizeof(DOUBLECOMPLEX_t);
    for (j = 0; j < data->columns; ++j) {
        *dst = z_nan;
        dst += cs;
    }
}


/************************
*  Triangular matrices  *
*************************/

/*
Copying upper/lower triangular part of matrices from contiguous fortran to numpy

This function does fill the other triangle with zeros and copies the diagonal.
*/
void
delinearize_CDOUBLE_trilu(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data,
                        int lower)
{
    if (lower) {
        /* Zero out L */
        zero_CDOUBLE_triu(dst_in, data);
        /* Copy triangular L from buffer */
        delinearize_CDOUBLE_tril(dst_in, src_in, data);
        /* Copy diagonal of L from buffer */
        delinearize_CDOUBLE_diag(dst_in, src_in, data);
    } else {
        /* Zero out R */
        zero_CDOUBLE_tril(dst_in, data);
        /* Copy triangular R from buffer */            
        delinearize_CDOUBLE_triu(dst_in, src_in, data);
    }
}




